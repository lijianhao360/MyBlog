[{"title":"Java基础核心知识点","url":"/MyBlog/2026/01/02/Java%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"一、JVM 内存模型1.1 堆内存堆内存是JVM中最大的一块内存区域，也是所有线程共享的内存区域，在JVM启动时创建，主要用于存储Java中的对象实例和数组。\n\n堆内存是GC（垃圾回收）的核心区域，垃圾回收器主要回收堆中不再被引用的对象实例，释放内存空间。\n堆内存可以细分为：新生代（Eden区 + 两个Survivor区 S0&#x2F;S1）、老年代、永久代（JDK1.7及以前）&#x2F;元空间（JDK1.8及以后，元空间存于本地内存，不在堆内）。\n特点：线程共享、内存空间大、内存分配效率较低、会发生内存溢出（OOM: OutOfMemoryError）。\n\n1.2 栈内存栈内存也叫虚拟机栈，是线程私有的内存区域，每个线程启动时都会创建一个对应的虚拟机栈，生命周期和线程一致。\n\n栈内存中存储的是一个个栈帧，每个方法被调用时就会创建一个栈帧，存放方法的局部变量、操作数栈、方法出口等信息，方法执行完毕栈帧出栈释放内存。\n栈的大小是固定的（可通过JVM参数调整），调用方法层级过深（如递归无终止条件）会导致栈溢出（StackOverflowError）。\n特点：线程私有、内存空间小、内存分配效率高、存取速度快，不存在垃圾回收。\n补充：本地方法栈与虚拟机栈功能类似，区别是本地方法栈为Native本地方法提供内存支撑。\n\n二、集合框架Java集合框架位于java.util包下，主要分为两大体系：Collection单列集合、Map双列集合，用于存储和操作一组数据，替代了早期的数组（数组长度固定，集合长度可变）。核心特点：存储引用数据类型、长度自动扩容、提供丰富的增删改查API。\n2.1 ArrayList 原理核心定义ArrayList是基于动态数组实现的List接口实现类，底层存储结构为Object数组，支持快速的随机访问，是开发中最常用的集合之一。\n底层核心原理\n初始化容量：JDK1.8中ArrayList默认初始化容量为0（懒加载），第一次添加元素时，会扩容至初始容量10；JDK1.7及以前默认初始化容量直接为10。\n扩容机制：当数组容量不足时，ArrayList会自动扩容，新容量 &#x3D; 原容量 + 原容量 &gt;&gt; 1（即扩容为原容量的1.5倍），并创建新数组，将原数组的数据复制到新数组中。\n底层数组：存储元素的核心数组为transient Object[] elementData，transient关键字表示该数组不会被序列化（序列化时会通过writeObject方法按需序列化有效元素）。\n\n核心特点\n优点：基于数组实现，随机访问效率极高（通过索引下标访问，时间复杂度O(1)）。\n缺点：增删元素效率低（数组是连续内存，增删元素需要移动后续元素，时间复杂度O(n)）；线程不安全，多线程环境下使用会出现并发修改异常（ConcurrentModificationException）。\n\n面试高频考点\nArrayList扩容是1.5倍，Vector扩容是2倍；Vector是线程安全的，效率低于ArrayList。\n解决ArrayList线程不安全的方案：使用Collections.synchronizedList(new ArrayList&lt;&gt;())，或使用JUC包下的CopyOnWriteArrayList。\n\n2.2 HashMap 底层实现核心定义HashMap是基于数组+链表+红黑树实现的Map接口实现类，存储键值对（Key-Value） 数据，允许Key和Value为null（Key只能有一个null，Value可以有多个null），线程不安全，是开发中最常用的双列集合。\nJDK1.8 底层核心结构HashMap的底层存储结构是 数组（哈希桶） + 链表 + 红黑树，核心设计是为了解决哈希冲突，平衡查询和增删效率：\n\n哈希桶数组：核心存储结构为Node[] table，每个数组元素是一个Node节点（存储hash值、Key、Value、下一个节点的引用），数组默认初始容量为16，容量必须是2的幂次方。\n链表：当多个键值对的哈希值相同，计算出的数组下标一致时，就会产生哈希冲突，此时会将这些节点以单向链表的形式挂载到同一个数组下标位置。\n红黑树：当链表的长度大于等于8，并且数组的容量大于等于64时，链表会自动转换为红黑树；当红黑树的节点数量小于等于6时，红黑树会转回链表。红黑树的作用是将链表的查询效率从O(n)提升至O(logn)。\n\n核心核心原理（哈希计算+存储流程）\n计算Key的哈希值：通过hash(key)方法计算Key的哈希值，对哈希值做扰动处理（高16位异或低16位），目的是减少哈希冲突，让哈希值分布更均匀。\n计算数组下标：通过 (数组长度 - 1) &amp; 哈希值 计算当前键值对应在数组中的下标位置（数组长度是2的幂次方，此运算等价于取模，效率更高）。\n存储元素：\n如果下标位置为空，直接将节点存入该位置；\n如果下标位置已有节点，判断Key是否相同（哈希值相同+equals返回true），相同则覆盖Value；\n如果Key不同，判断是链表还是红黑树，分别执行链表追加&#x2F;红黑树插入逻辑。\n\n\n\n核心参数与扩容机制\n负载因子（loadFactor）：默认值为0.75，表示数组的扩容阈值 &#x3D; 数组容量 * 负载因子（如初始容量16，阈值&#x3D;12）。\n扩容触发条件：当HashMap中存储的键值对数量 &gt;&#x3D; 扩容阈值 时，触发扩容，新容量 &#x3D; 原容量 * 2（保证容量始终是2的幂次方），并重新计算所有节点的下标，迁移到新数组中。\n负载因子0.75是时间和空间的平衡值：因子太小，扩容频繁，空间利用率低；因子太大，哈希冲突概率高，查询效率低。\n\n核心特点\n线程不安全，多线程环境下扩容时会出现链表环，导致死循环，也会出现并发修改异常。\n存取效率极高，理想情况下时间复杂度为O(1)，最坏情况下（红黑树）为O(logn)。\n元素无序存储，HashMap不保证元素的存取顺序和遍历顺序一致。\n\n面试高频考点\nHashMap的初始容量是16，为什么必须是2的幂次方？答：保证(容量-1)&amp;哈希值的运算等价于取模，提升计算效率，同时让哈希值分布更均匀，减少哈希冲突。\nJDK1.7和JDK1.8 HashMap的区别：JDK1.7是数组+链表，扩容时会出现死循环；JDK1.8是数组+链表+红黑树，优化了哈希算法，解决了死循环问题。\nHashMap和HashTable的区别：HashTable线程安全，效率低；HashMap线程不安全，效率高；HashTable不允许Key&#x2F;Value为null，HashMap允许。\n\n","categories":["Java"],"tags":["基础"]}]